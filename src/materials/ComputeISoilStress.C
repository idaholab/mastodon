/*************************************************/
/*           DO NOT MODIFY THIS HEADER           */
/*                                               */
/*                     MASTODON                  */
/*                                               */
/*    (c) 2015 Battelle Energy Alliance, LLC     */
/*            ALL RIGHTS RESERVED                */
/*                                               */
/*   Prepared by Battelle Energy Alliance, LLC   */
/*     With the U. S. Department of Energy       */
/*                                               */
/*     See COPYRIGHT for full restrictions       */
/*************************************************/

// This code was implemented in colloboration with Ozgun Numanoglu
// (numanog2@illinois.edu) and Omar Baltaji (baltaji2@illinois.edu) from UIUC.

#include "ComputeISoilStress.h"

#include "MooseMesh.h"
#include "Function.h"
#include "MastodonUtils.h"
#include "ISoilUtils.h"
#include "Conversion.h"
#include "FEProblem.h"
#include <iostream>

registerMooseObject("MastodonApp", ComputeISoilStress);

template <>
InputParameters
validParams<ComputeISoilStress>()
{
  InputParameters params = validParams<ComputeFiniteStrainElasticStress>();
  params.addClassDescription("Compute total stress for the nonlinear material "
                             "model I-Soil using a backbone curve.");
  params.addRequiredCoupledVar("layer_variable",
                               "The auxvariable providing the soil layer identification.");
  params.addRequiredParam<std::vector<unsigned int>>(
      "layer_ids",
      "Vector of layer ids that map one-to-one to the rest of the "
      "soil layer parameters provided as input.");
  params.addRequiredParam<std::vector<Real>>("poissons_ratio",
                                             "Poissons's ratio for the soil layers. The "
                                             "size of the vector should be same as the size of "
                                             "layer_ids.");
  params.addParam<Real>("b_exp",
                        0.0,
                        "The exponential factors for pressure "
                        "dependent stiffness for all the soil "
                        "layers.");
  params.addParam<std::vector<Real>>("p_ref",
                                     "The reference pressure at which "
                                     "the parameters are defined for "
                                     "each soil layer. If 'soil_type = "
                                     "darendeli', then the reference "
                                     "pressure must be input in kilopascals.");
  params.addParam<Real>("a0",
                        1.0,
                        "The first coefficient for pressure dependent yield strength "
                        "calculation for all the soil layers. If a0 = 1, a1 = 0 and "
                        "a2=0 for one soil layer, then the yield strength of that "
                        "layer is independent of pressure.");
  params.addParam<Real>("a1",
                        0.0,
                        "The second coefficient for pressure dependent yield "
                        "strength calculation for all the soil layers. If a0 = "
                        "1, a1 = 0, a2 = 0 for one soil layer, then the yield "
                        "strength of that layer is independent of pressure.");
  params.addParam<Real>("a2",
                        0.0,
                        "The third coefficient for pressure dependent yield "
                        "strength calculation for all the soil layers. If a0 = "
                        "1, a1=0 and a2=0 for one soil layer, then the yield "
                        "strength of that layer is independent of pressure.");
  params.addParam<Real>("tension_pressure_cut_off",
                        -1.0,
                        "The tension cut-off for all the soil layers. If the "
                        "pressure becomes lower than this value, then the "
                        "stiffness of the soil reduces to zero. A negative "
                        "pressure indicates tension. The default "
                        "value is -1.0 for all the soil layers.");
  params.addParam<bool>("pressure_dependency",
                        false,
                        "Set to true to turn on pressure dependent stiffness "
                        "and yield strength calculation.");
  params.addParam<bool>(
      "wave_speed_calculation", true, "Set to false to turn off P and S wave speed calculation.");
  params.addParam<std::vector<FunctionName>>(
      "initial_soil_stress",
      "A list of functions describing the initial stress. There "
      "must be 9 functions, corresponding to the xx, yx, zx, xy, yy, zy, xz, yz, "
      "zz components respectively. If not provided, all components of the "
      "initial stress will be zero.");
  // params for specific backbone types
  MooseEnum soil_type("user_defined darendeli gqh thin_layer");
  params.addRequiredParam<MooseEnum>(
      "soil_type",
      soil_type,
      "This parameter determines the type of backbone curve used. Use 'user_defined' "
      "for a user defined backbone curve provided in a data file, 'darendeli' "
      "if the backbone curve is to be determined using Darandeli equations, 'gqh' "
      "if the backbone curve is determined using the GQ/H approach and 'thin_layer' if the soil is "
      "being used to simulate a thin-layer friction interface.");
  // params required for user_defined backbone curve: soil_type = 'user_defined'
  params.addParam<std::vector<FileName>>(
      "backbone_curve_files",
      "The vector of file names of the files containing "
      "stress-strain backbone curves for the different soil layers. The "
      "size of the vector should be same as the size of layer_ids. All files "
      "should contain the same number of stress-strain points. Headers are not "
      "expected and it is assumed that the first column corresponds to strain values "
      "and the second column corresponds to the stress values. Additionally, two "
      "segments of a backbone curve cannot have the same slope.");
  // params required for soil_type = 'darendeli', 'GQ/H' and 'thin_layer'
  params.addRequiredParam<std::vector<Real>>("initial_shear_modulus",
                                             "The initial shear modulus of the soil layers. ");
  params.addParam<MaterialPropertyName>("shear_modulus",
                                        "Name of Material Property  or a constant real number "
                                        "defining the shear modulus of the materials.");
  // params required for soil_type = 'darendeli' and 'GQ/H'
  params.addParam<unsigned int>("number_of_points",
                                "The total number of data points in which the "
                                "backbone curve needs to be split for all soil "
                                "layers (required for Darandeli or GQ/H type backbone curves).");
  // params required for Darandeli backbone curve: soil_type = 'darendeli'
  params.addParam<std::vector<Real>>("over_consolidation_ratio",
                                     "The over consolidation ratio of the soil "
                                     "layers. Required for Darandeli backbone curve.");
  params.addParam<std::vector<Real>>(
      "plasticity_index",
      "The plasticity index of the soil layers. Required for Darandeli backbone curve.");
  // params required for GQ/H backbone curve: soil_type = "gqh"
  params.addParam<std::vector<Real>>("theta_1",
                                     "The curve fit coefficient for "
                                     "GQ/H model"
                                     "for each soil layer.");
  params.addParam<std::vector<Real>>("theta_2",
                                     "The curve fit coefficient for "
                                     "GQ/H model"
                                     "for each soil layer.");
  params.addParam<std::vector<Real>>("theta_3",
                                     "The curve fit coefficient for "
                                     "GQ/H model"
                                     "for each soil layer.");
  params.addParam<std::vector<Real>>("theta_4",
                                     "The curve fit coefficient for "
                                     "GQ/H model"
                                     "for each soil layer.");
  params.addParam<std::vector<Real>>("theta_5",
                                     "The curve fit coefficient for "
                                     "GQ/H model"
                                     "for each soil layer.");
  params.addParam<std::vector<Real>>("taumax",
                                     "The ultimate shear strength of "
                                     "the soil layers. Required for "
                                     "GQ/H model");
  // params required for thin_layer contact model soil_type = "thin_layer"
  params.addParam<std::vector<Real>>("friction_coefficient",
                                     "Friction coefficients of the thin layers.");
  params.addParam<std::vector<Real>>("hardening_ratio",
                                     "Post-yield hardening ratios of the layers.");
  return params;
}

ComputeISoilStress::ComputeISoilStress(const InputParameters & parameters)
  : ComputeFiniteStrainElasticStress(parameters),
    _strain_increment(getMaterialProperty<RankTwoTensor>(_base_name + "strain_increment")),
    _base_models(),
    _stress_model(),
    _stress_model_old(),
    _yield_stress(), // *** YIELD STRAIN NOT YIELD STRESS ***
    _youngs(),
    _soil_layer_variable(coupledValue("layer_variable")),
    _layer_ids(getParam<std::vector<unsigned int>>("layer_ids")),
    _wave_speed_calculation(getParam<bool>("wave_speed_calculation")),
    _poissons_ratio(getParam<std::vector<Real>>("poissons_ratio")),
    _density(_wave_speed_calculation ? &getMaterialProperty<Real>("density") : nullptr),
    _b_exp(getParam<Real>("b_exp")),
    _p_ref(getParam<std::vector<Real>>("p_ref")),
    _a0(getParam<Real>("a0")),
    _a1(getParam<Real>("a1")),
    _a2(getParam<Real>("a2")),
    _p0(getParam<Real>("tension_pressure_cut_off")),
    _pressure_dependency(getParam<bool>("pressure_dependency")),
    _strength_pressure_correction(1.0),
    _stiffness_pressure_correction(1.0),
    _shear_wave_speed(_wave_speed_calculation ? &declareProperty<Real>("shear_wave_speed")
                                              : nullptr),
    _P_wave_speed(_wave_speed_calculation ? &declareProperty<Real>("P_wave_speed") : nullptr),
    _tangent_modulus(0.0),
    _pos(0),
    _initial_soil_stress_provided(
        getParam<std::vector<FunctionName>>("initial_soil_stress").size() ==
        LIBMESH_DIM * LIBMESH_DIM)
{

  // checking that density, and Poisson's ratio are the same size as layer_ids
  if (_poissons_ratio.size() != _layer_ids.size())
    mooseError("Error in " + name() + ". Poisson's ratio should be of the same "
                                      "size as layer_ids.");
  // checks for pressure dependency
  if (_pressure_dependency && _b_exp == 0.0)
    mooseWarning("Warning in " + name() + ". Pressure dependency is set to true "
                                          "but b_exp is set to 0.0. Stiffness "
                                          "pressure dependency is NOT "
                                          "turned on.");
  if (_pressure_dependency && (_a0 == 1.0 && _a1 == 0.0 && _a2 == 0.0))
    mooseWarning("Warning in " + name() +
                 ". Pressure dependency is set to true but a0, a1 and a2 are "
                 "set to 1.0, 0.0 and 0.0, respectively. Strength "
                 "pressure dependency is NOT turned on.");
  if (_pressure_dependency && (_a0 == 0.0 && _a1 == 0.0 && _a2 == 0.0))
    mooseError("Error in " + name() +
               ". When pressure dependency is turned on, "
               "all three strength coefficients, a0, a1, and a2, "
               "cannot simultaneously be set to 0.0. This "
               "combination results in division by 0.");
  if (_pressure_dependency && _p_ref.size() != _layer_ids.size())
    mooseError("Error in " + name() + ". When pressure dependency is turned on, "
                                      "a positive reference pressure "
                                      "(compressive) has to be defined for all "
                                      "the soil layers and the same number of reference "
                                      "pressures as soil layers should be provided.");
  if (_pressure_dependency && MastodonUtils::isNegativeOrZero(_p_ref))
    mooseError("Error in " + name() +
               ". Please provide positive (compressive) values for reference pressure.");

  // Initializing backbone curve
  const MooseEnum & soil_type = getParam<MooseEnum>("soil_type");
  std::vector<std::vector<Real>> backbone_stress(_layer_ids.size());
  std::vector<std::vector<Real>> backbone_strain(_layer_ids.size());
  std::vector<Real> initial_shear_modulus = getParam<std::vector<Real>>("initial_shear_modulus");

  // Calculating backbone curve for soil_type = user_defined
  if (soil_type == "user_defined")
  {
    std::vector<FileName> backbone_curve_files =
        getParam<std::vector<FileName>>("backbone_curve_files");
    if (backbone_curve_files.size() != _layer_ids.size())
      mooseError("Error in " + name() +
                 ". A vector of file names needs to "
                 "be provided for `backbone_curve_files` and the size of this vector "
                 "should be same as that of `layers_ids`.");
    ISoilUtils::computeUserDefinedBackbone(
        backbone_stress, backbone_strain, _layer_ids, backbone_curve_files, name());
  }
  // Calculating backbone curve for soil_type = darendeli
  else if (soil_type == "darendeli")
  {
    std::vector<Real> over_consolidation_ratio =
        getParam<std::vector<Real>>("over_consolidation_ratio");
    std::vector<Real> plasticity_index = getParam<std::vector<Real>>("plasticity_index");
    unsigned int number_of_points = getParam<unsigned int>("number_of_points");
    if (initial_shear_modulus.size() != _layer_ids.size() ||
        over_consolidation_ratio.size() != _layer_ids.size() ||
        plasticity_index.size() != _layer_ids.size())
      mooseError("Error in " + name() + ". initial_shear_modulus, "
                                        "over_consolidation_ratio and plasticity_index must be "
                                        "of the same size as layer_ids.");
    if (MastodonUtils::isNegativeOrZero(over_consolidation_ratio) || number_of_points <= 0 ||
        MastodonUtils::isNegativeOrZero(initial_shear_modulus))
      mooseError("Error in " + name() + ". Positive values have to be provided "
                                        "for over_consolidation_ratio, "
                                        "number_of_points, "
                                        "and initial_shear_modulus.");
    ISoilUtils::computeDarendeliBackbone(backbone_stress,
                                         backbone_strain,
                                         _layer_ids,
                                         initial_shear_modulus,
                                         over_consolidation_ratio,
                                         plasticity_index,
                                         _p_ref,
                                         number_of_points,
                                         name());
  }
  // Calculating backbone curve for soil_type = gqh
  else if (soil_type == "gqh")
  {
    unsigned int number_of_points = getParam<unsigned int>("number_of_points");
    std::vector<Real> theta_1 = getParam<std::vector<Real>>("theta_1");
    std::vector<Real> theta_2 = getParam<std::vector<Real>>("theta_2");
    std::vector<Real> theta_3 = getParam<std::vector<Real>>("theta_3");
    std::vector<Real> theta_4 = getParam<std::vector<Real>>("theta_4");
    std::vector<Real> theta_5 = getParam<std::vector<Real>>("theta_5");
    std::vector<Real> taumax = getParam<std::vector<Real>>("taumax");
    std::vector<std::vector<Real>> modulus(_layer_ids.size());
    if (initial_shear_modulus.size() != _layer_ids.size() || theta_1.size() != _layer_ids.size() ||
        theta_2.size() != _layer_ids.size() || theta_3.size() != _layer_ids.size() ||
        theta_4.size() != _layer_ids.size() || theta_5.size() != _layer_ids.size() ||
        taumax.size() != _layer_ids.size())
      mooseError("Error in " + name() +
                 ". initial_shear_modulus, theta_1, "
                 "theta_2, theta_3, theta_4, theta_5 and taumax should be of the "
                 "same size as layer_ids.");
    if (number_of_points <= 0 || MastodonUtils::isNegativeOrZero(taumax) ||
        MastodonUtils::isNegativeOrZero(initial_shear_modulus))
      mooseError("Error in " + name() + ". Please provide positive values for number of points, "
                                        "taumax and initial_shear_modulus.");
    ISoilUtils::computeGQHBackbone(backbone_stress,
                                   backbone_strain,
                                   _layer_ids,
                                   initial_shear_modulus,
                                   number_of_points,
                                   theta_1,
                                   theta_2,
                                   theta_3,
                                   theta_4,
                                   theta_5,
                                   taumax);
  }
  // Calculating backbone curve for soil_type = thin_layer
  else if (soil_type == "thin_layer")
  {
    _pressure_dependency = true;
    _a0 = 0.0;
    _a1 = 0.0;
    _a2 = 1.0;
    std::vector<Real> friction_coefficient = getParam<std::vector<Real>>("friction_coefficient");
    std::vector<Real> hardening_ratio = getParam<std::vector<Real>>("hardening_ratio");
    if (initial_shear_modulus.size() != _layer_ids.size() ||
        friction_coefficient.size() != _layer_ids.size() ||
        hardening_ratio.size() != _layer_ids.size())
      mooseError("Error in " + name() + ". initial_shear_modulus, friction_coefficient, "
                                        "hardening_ratio and p_ref must be "
                                        "of the same size as layer_ids.");
    if (MastodonUtils::isNegativeOrZero(initial_shear_modulus) ||
        MastodonUtils::isNegativeOrZero(friction_coefficient) ||
        MastodonUtils::isNegativeOrZero(hardening_ratio))
      mooseError("Error in " + name() + ". Positive values have to be provided "
                                        "for `initial_shear_modulus`, "
                                        "`friction_coefficient` and `hardening_ratio`");
    ISoilUtils::computeCoulombBackbone(backbone_stress,
                                       backbone_strain,
                                       _layer_ids,
                                       initial_shear_modulus,
                                       friction_coefficient,
                                       hardening_ratio,
                                       _p_ref,
                                       name());
  }
  else
    mooseError("Error in " + name() + ". The parameter soil_type is invalid.");
  // Deconstructing the backbone curves for all the soil layers into
  // elastic-perfectly-plastic components. Each backbone curve is split up into
  // a set of youngs modulus and yield stress pairs.
  _youngs.resize(_layer_ids.size());
  _yield_stress.resize(_layer_ids.size());
  ISoilUtils::computeSoilLayerProperties(
      _youngs,
      _yield_stress, // *** CALCULATES YIELD STRAIN NOT YIELD STRESS ***
      backbone_stress,
      backbone_strain,
      _layer_ids,
      _poissons_ratio,
      name());
  _stress_model.resize(_youngs[0].size());
  _stress_model_old.resize(_youngs[0].size());
  _base_models.resize(_youngs[0].size());
  for (std::size_t i = 0; i < _youngs[0].size(); i++)
  {
    _base_models[i] = Moose::stringify(i);
    _stress_model[i] = &declareProperty<RankTwoTensor>(_base_models[i] + "_stress_model");
    _stress_model_old[i] =
        &getMaterialPropertyOld<RankTwoTensor>(_base_models[i] + "_stress_model");
  }

  const std::vector<FunctionName> & fcn_names(
      getParam<std::vector<FunctionName>>("initial_soil_stress"));
  const unsigned num = fcn_names.size();

  if (!(num == 0 || num == LIBMESH_DIM * LIBMESH_DIM))
    mooseError("Either zero or ",
               LIBMESH_DIM * LIBMESH_DIM,
               " initial soil stress functions must be provided.  You supplied ",
               num,
               "\n");

  _initial_soil_stress.resize(num);
  for (unsigned i = 0; i < num; ++i)
    _initial_soil_stress[i] = &getFunctionByName(fcn_names[i]);

  _stress_new.zero();
  _individual_stress_increment.zero();
  _deviatoric_trial_stress.zero();

  // // checking that the input and the backbone shear modulus values are consistent.
  std::vector<Real> initial_shear;
  initial_shear.resize(_poissons_ratio.size());
  Real tmp = 0.0;
  for (int j = 0; j < _poissons_ratio.size(); j++)
  {
    tmp = 0.0;
    for (int i = 0; i < _base_models.size(); i++)
    {
      tmp += _youngs[j][i] / (2 * (1 + _poissons_ratio[j]));
    }
    initial_shear[j] = tmp;
  }

  bool value_bool = MastodonUtils::checkEqual(initial_shear, initial_shear_modulus, 5.0);
  if (value_bool == false)
    mooseWarning(
        "Shear moduli inferred from the backbone curve are different from the input values."
        " Using the backbone curve inferred value for further computations.");
}

void
ComputeISoilStress::initQpStatefulProperties()
{
  ComputeStressBase::initQpStatefulProperties();
  if (_initial_soil_stress_provided)
  {
    for (unsigned i = 0; i < LIBMESH_DIM; ++i)
      for (unsigned j = 0; j < LIBMESH_DIM; ++j)
        _stress[_qp](i, j) = _initial_soil_stress[i * LIBMESH_DIM + j]->value(_t, _q_point[_qp]);
  }
  for (std::size_t i = 0; i < _base_models.size(); i++)
    (*_stress_model[i])[_qp].zero();

  // Determine the current id for the soil. The variable which is a Real must be
  // converted to a unsigned int for lookup, so first
  // it is rounded to avoid Real values that are just below the desired value.
  _current_id = static_cast<unsigned int>(std::round(_soil_layer_variable[_qp]));
  // Get the position of the current id in the layer_ids array
  _pos = find(_layer_ids.begin(), _layer_ids.end(), _current_id) - _layer_ids.begin();

  if (_wave_speed_calculation)
  {
    Real initial_youngs = 0.0;
    for (std::size_t i = 0; i < _base_models.size(); i++)
      initial_youngs += _youngs[_pos][i];

    // shear wave speed is sqrt(shear_modulus/density)
    (*_shear_wave_speed)[_qp] =
        std::sqrt(initial_youngs / (2.0 * (1.0 + _poissons_ratio[_pos])) / (*_density)[_qp]);

    // P wave speed is sqrt(P wave modulus/density)
    (*_P_wave_speed)[_qp] =
        std::sqrt(initial_youngs * (1.0 - _poissons_ratio[_pos]) / (1.0 + _poissons_ratio[_pos]) /
                  (1.0 - 2.0 * _poissons_ratio[_pos]) / (*_density)[_qp]);
  }

  // determine the lateral and vertical stresses
  Real residual_vertical = _stress[_qp](2, 2);
  Real residual_xx = _stress[_qp](0, 0);
  Real residual_yy = _stress[_qp](1, 1);
  Real mean_stress = _stress[_qp].trace() / (-3.0);

  if (_pressure_dependency)
  {
    _stiffness_pressure_correction = pow((mean_stress - _p0) / _p_ref[_pos], _b_exp);
    _strength_pressure_correction =
        std::sqrt(_a0 + _a1 * (mean_stress - _p0) +
                  _a2 * (mean_stress - _p0) * (mean_stress - _p0)) /
        std::sqrt(_a0 + _a1 * (_p_ref[_pos]) + _a2 * (_p_ref[_pos]) * (_p_ref[_pos]));
  }

  // Calculate the K0 consistent stress distribution
  RankTwoTensor dev_model;
  for (std::size_t i = 0; i < _base_models.size(); i++)
  {
    Real _mean_pressure = 0.0;
    if (residual_vertical != 0.0)
    {
      Real sum_youngs = 0.0;

      for (std::size_t j = i; j < _base_models.size(); j++)
        sum_youngs += _youngs[_pos][j];

      (*_stress_model[i])[_qp](2, 2) = residual_vertical * _youngs[_pos][i] / sum_youngs;
      (*_stress_model[i])[_qp](0, 0) = residual_xx * _youngs[_pos][i] / sum_youngs;
      (*_stress_model[i])[_qp](1, 1) = residual_yy * _youngs[_pos][i] / sum_youngs;
      dev_model = ((*_stress_model[i])[_qp]).deviatoric() / _youngs[_pos][i];
      _mean_pressure = (*_stress_model[i])[_qp].trace() / 3.0;
      Real J2_model = dev_model.doubleContraction(dev_model);
      Real dev_stress_model = std::sqrt(3.0 / 2.0 * J2_model);
      if (dev_stress_model > _yield_stress[_pos][i] * _strength_pressure_correction)
        dev_model *= (_yield_stress[_pos][i] * _strength_pressure_correction) / dev_stress_model;

      (*_stress_model[i])[_qp] = dev_model * _youngs[_pos][i]; // stress_model contains only the
                                                               // deviatoric part of the stress
    }
    residual_vertical = residual_vertical - (*_stress_model[i])[_qp](2, 2) - _mean_pressure;
    residual_xx = residual_xx - (*_stress_model[i])[_qp](0, 0) - _mean_pressure;
    residual_yy = residual_yy - (*_stress_model[i])[_qp](1, 1) - _mean_pressure;
  }
}

void
ComputeISoilStress::computeQpStress()
{
  // Nothing to update during the first time step, return immediately
  if (_t_step == 0)
    return;

  _stress_new.zero();
  computeStress();
  _stress[_qp] = _rotation_increment[_qp] * _stress_new * _rotation_increment[_qp].transpose();

  // Compute dstress_dstrain
  if (_tangent_modulus == 0.0)
    _tangent_modulus = _youngs[_pos][_youngs.size() - 1];

  Real lame_1 = _elasticity_tensor[_qp](0, 0, 1, 1);
  Real lame_2 = (_elasticity_tensor[_qp](0, 0, 0, 0) - lame_1) / 2;
  Real initial_youngs = (lame_2 * (3 * lame_1 + 2 * lame_2)) / (lame_1 + lame_2);

  _Jacobian_mult[_qp] =
      _elasticity_tensor[_qp] * _tangent_modulus / initial_youngs; // This is NOT the exact jacobian
}

void
ComputeISoilStress::computeStress()
{
  if (_t_step == 0)
    return;

  // Determine the current id for the soil. The variable which is a Real must be
  // converted to a unsigned int for lookup, so first
  // it is rounded to avoid Real values that are just below the desired value.
  _current_id = static_cast<unsigned int>(std::round(_soil_layer_variable[_qp]));

  // Get the position of the current id in the layer_ids array
  _pos = find(_layer_ids.begin(), _layer_ids.end(), _current_id) - _layer_ids.begin();

  _individual_stress_increment.zero();

  _deviatoric_trial_stress.zero();

  _tangent_modulus = 0.0;

  // current pressure calculation
  Real mean_stress = _stress_old[_qp].trace() / (-3.0);
  if (mean_stress < _p0)
    mean_stress = 0.0;

  if (_pressure_dependency)
  {
    _stiffness_pressure_correction = pow((mean_stress - _p0) / _p_ref[_pos], _b_exp);
    _strength_pressure_correction =
        std::sqrt(_a0 + _a1 * (mean_stress - _p0) +
                  _a2 * (mean_stress - _p0) * (mean_stress - _p0)) /
        std::sqrt(_a0 + _a1 * (_p_ref[_pos]) + _a2 * (_p_ref[_pos]) * (_p_ref[_pos]));
  }

  _mean_pressure = 0.0;

  Real lame_1 = _elasticity_tensor[_qp](0, 0, 1, 1);
  Real lame_2 = (_elasticity_tensor[_qp](0, 0, 0, 0) - lame_1) / 2;
  Real initial_youngs = (lame_2 * (3 * lame_1 + 2 * lame_2)) / (lame_1 + lame_2);

  // compute trial stress increment - note that _elasticity_tensor here
  _individual_stress_increment =
      _elasticity_tensor[_qp] * (_strain_increment[_qp]) / initial_youngs;

  _mean_pressure_tmp = _individual_stress_increment.trace() / 3.0 * _stiffness_pressure_correction;

  _deviatoric_trial_stress_tmp =
      _individual_stress_increment.deviatoric() * _stiffness_pressure_correction;

  _dev_trial_stress_squared = 0.0;

  _effective_trial_stress = 0.0;

  _yield_condition = 0.0;

  for (std::size_t i = 0; i < _base_models.size(); i++)
  {

    // calculate pressure for each element
    _mean_pressure += _mean_pressure_tmp * _youngs[_pos][i];

    // compute the deviatoric trial stress normalized by non pressure dependent
    // youngs modulus.
    _deviatoric_trial_stress =
        _deviatoric_trial_stress_tmp + (*_stress_model_old[i])[_qp] / (_youngs[_pos][i]);

    // compute the effective trial stress
    _dev_trial_stress_squared =
        _deviatoric_trial_stress.doubleContraction(_deviatoric_trial_stress);
    _effective_trial_stress = std::sqrt(3.0 / 2.0 * _dev_trial_stress_squared);

    // check yield condition and calculate plastic strain
    _yield_condition =
        _effective_trial_stress - _yield_stress[_pos][i] * _strength_pressure_correction;

    if (_yield_condition > 0.0)
      _deviatoric_trial_stress *=
          _yield_stress[_pos][i] * _strength_pressure_correction / _effective_trial_stress;
    else
      _tangent_modulus += _youngs[_pos][i];

    (*_stress_model[i])[_qp] = _youngs[_pos][i] * (_deviatoric_trial_stress);

    _stress_new += (*_stress_model[i])[_qp];
  }
  _stress_new(0, 0) += _mean_pressure - mean_stress;
  _stress_new(1, 1) += _mean_pressure - mean_stress;
  _stress_new(2, 2) += _mean_pressure - mean_stress;

  _tangent_modulus *= _stiffness_pressure_correction;
}
